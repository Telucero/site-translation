{"config":{"lang":["en","es","fr","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"learn/","title":"Learn","text":"<p>Launching a decentralized network has traditionally been a challenging and time-consuming process, requiring expertise in infrastructure, security, and operational setup. Tanssi simplifies this journey by removing the complexities and making network deployment fast and accessible.</p> <p>This section explores the core elements that define Tanssi as a leading solution for network development. Whether you\u2019re starting your journey into decentralized networks or deepening your understanding of Tanssi\u2019s unique capabilities, these documents provide everything you need to understand how Tanssi sets a new standard for network infrastructure.</p>"},{"location":"learn/#explore-this-section","title":"Explore This Section","text":"<p>:::INSERT_GENERATED_CARDS:::</p>"},{"location":"learn/#jump-right-into-building","title":"Jump Right into BuildingBuild Your Network","text":"<p>Start your Tanssi journey here if you prefer to learn by doing.</p> <p>Learn how to design and customize your network with ready-to-use templates and tools tailored to your technical needs.</p>"},{"location":"learn/framework/modules/","title":"Network Framework Modules","text":""},{"location":"learn/framework/modules/#introduction","title":"Introduction","text":"<p>The Substrate framework provides complete and ready-to-use implementations of the main functions a Tanssi network needs to work properly, including cryptography, consensus, governance, and so on. These implementations are fully customizable and could be replaced with custom logic if needed.</p> <p>When building the Runtime, which defines the state transition rules between two blocks applied to a set of transactions, the intended behavior and features of the blockchain need to be set by determining the rules of the state transition.</p> <p>To build the Runtime, Substrate provides many built-in modules (also known as pallets) that can be freely used as building blocks to compose and interact with any other custom-made modules, allowing teams to create unique behaviors according to the specific requirements of their Tanssi network.</p> <p></p>"},{"location":"learn/framework/modules/#built-in-modules","title":"Built-in Modules","text":"<p>When designing and writing the rules of a Tanssi network, the available set of functional modules brings a solution to many of the coding requirements that would otherwise need to be built from scratch.</p> <p>Here is a list of some of the most popular modules:</p> <ul> <li>Balances - it provides functions for handling accounts and balances for the Tanssi network native currency</li> <li>Assets - it provides functions for handling any type of fungible tokens</li> <li>NFTs - it provides functions for dealing with non-fungible tokens</li> <li>Democracy - it provides functions to manage and administer general stakeholder voting</li> <li>Multisig - it provides functions for multi-signature dispatch</li> <li>Recovery - it provides functions to allow users to regain access to their accounts when the private key is lost. This works by granting other accounts the right to sign transactions on behalf of the lost account (note that it is necessary to have previously chosen the authorized accounts)</li> <li>Staking - it provides functions to administer staked tokens, support rewarding, slashing, depositing, withdrawing, and so on</li> </ul> <p>In addition to those previously listed, other modules like identity, smart contracts, vesting, and many others that are freely available can speed up the development of the Tanssi network and, consequently, the time to market.</p> <p>Note</p> <p>The framework also includes other modules that provide core protocol functionality, such as consensus and low-level data encoding.</p>"},{"location":"learn/framework/modules/#custom-modules","title":"Custom-Made Modules","text":"<p>Developers creating new modules enjoy complete freedom to express any desired behavior in the core logic of the blockchain, like exposing new transactions, storing sensible information, and validating and enforcing business logic.</p> <p>As explained in the Architecture article, a module needs to be able to communicate with the core client by exposing and integrating with a very specific API that allows the runtime to expose transactions, access storage, and code and decode information stored on-chain. It also needs to include many other required wiring codes that make the module work in the node.</p> <p>To improve developer experience when writing modules, Substrate relies heavily on Rust macros. Macros are special instructions that automatically expand to Rust code just before compile-time, allowing modules to keep up to seven times the amount of code out of sight of the developers. This allows developers to focus on the specific functional requirements when writing modules instead of dealing with technicalities and the necessary scaffolding code.</p> <p>All modules in Substrate, including custom-made ones, implement these attribute macros, of which the first three are mandatory:</p> <ul> <li><code>#[frame_support::pallet]</code> - this attribute is the entry point that marks the module as usable in the runtime</li> <li><code>#[pallet::pallet]</code> - applied to a structure that is used to retrieve module information easily</li> <li><code>#[pallet::config]</code> - is a required attribute to define the configuration for the data types of the module</li> <li><code>#[pallet::call]</code> -  this macro is used to define functions that will be exposed as transactions, allowing them to be dispatched to the runtime. It is here that the developers add their custom transactions and logic</li> <li><code>#[pallet::error]</code> - as transactions may not be successful (insufficient funds, as an error example), and for security reasons, a custom module can never end up throwing an exception, all the possible errors are to be identified and listed in an enum to be returned upon an unsuccessful execution</li> <li><code>#[pallet::event]</code> - events can be defined and used as a means to provide more information to the user</li> <li><code>#[pallet::storage]</code> - this macro is used to define elements that will be persisted in storage. As resources are scarce in a blockchain, it should be used wisely to store only sensible information</li> </ul> <p>All these macros act as attributes that must be applied to the code just above Rust modules, functions, structures, enums, types, etc., allowing the module to be built and added to the runtime, which, in time, will expose the custom logic to the outer world, as exposed in the following section.</p>"},{"location":"learn/framework/modules/#custom-module-example","title":"Custom Module Example","text":"<p>As an example of a custom module, the following code (not intended for production use) showcases the use of the previously mentioned macros by presenting a simple lottery with minimal functionality, exposing two transactions:</p> <ul> <li> <p>buy_ticket - this transaction verifies that the user signing the request has not already bought a ticket and has enough funds to pay for it. If everything is fine, the module transfers the ticket price to a special account and registers the user as a participant for the prize</p> </li> <li> <p>award_prize - this transaction generates a random number to pick the winner from the list of participants. The winner gets the total amount of the funds transferred to the module's special account</p> </li> </ul> <pre><code>#![cfg_attr(not(feature = \"std\"), no_std)]\n\n/// Learn more about FRAME and the core library of Substrate FRAME pallets:\n/// &lt;https://docs.substrate.io/reference/frame-pallets/&gt;\npub use pallet::*;\n\n#[frame_support::pallet(dev_mode)]\npub mod pallet {\n\n    use super::*;\n    use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};\n    use frame_system::pallet_prelude::*;\n    use scale_info::prelude::vec::Vec;\n\n    use frame_support::\n    {\n        sp_runtime::traits::AccountIdConversion,\n        traits:: {\n            Currency, ExistenceRequirement, Randomness\n        },\n        PalletId,\n    };\n\n    type BalanceOf&lt;T&gt; = \n        &lt;&lt;T as Config&gt;::Currency as Currency&lt;&lt;T as frame_system::Config&gt;::AccountId&gt;&gt;::Balance;\n\n    #[pallet::pallet]\n    pub struct Pallet&lt;T&gt;(_);\n\n    /// Configure the module by specifying the parameters and types on which it depends.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n\n        // Event definition\n        type RuntimeEvent: From&lt;Event&lt;Self&gt;&gt; \n            + IsType&lt;&lt;Self as frame_system::Config&gt;::RuntimeEvent&gt;;\n\n        // Currency \n        type Currency: Currency&lt;Self::AccountId&gt;;\n\n        // Randomness\n        type MyRandomness: Randomness&lt;Self::Hash, BlockNumberFor&lt;Self&gt;&gt;;\n\n        // Ticket cost\n        #[pallet::constant]\n        type TicketCost: Get&lt;BalanceOf&lt;Self&gt;&gt;;\n\n        // Maximum number of participants\n        #[pallet::constant]\n        type MaxParticipants: Get&lt;u32&gt;;\n\n        // Module Id\n        #[pallet::constant]\n        type PalletId: Get&lt;PalletId&gt;;\n    }\n\n    // The pallet's runtime storage items.\n    #[pallet::storage]\n    #[pallet::getter(fn get_participants)]\n    pub(super) type Participants&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        BoundedVec&lt;T::AccountId, T::MaxParticipants&gt;,\n        OptionQuery\n    &gt;;\n\n    #[pallet::storage]\n    #[pallet::getter(fn get_nonce)]\n    pub(super) type Nonce&lt;T: Config&gt; = StorageValue&lt;\n        _,\n        u64,\n        ValueQuery\n    &gt;;\n\n    // Pallets use events to inform users when important changes are made.\n    // https://docs.substrate.io/main-docs/build/events-errors/\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event&lt;T: Config&gt; {\n        /// Event emitted when a ticket is bought\n        TicketBought { who: T::AccountId },\n        /// Event emitted when the prize is awarded\n        PrizeAwarded { winner: T::AccountId },\n        /// Event emitted when the prize is to be awarded, but there are no participants\n        ThereAreNoParticipants,\n    }\n\n    // Errors inform users that something went wrong\n    #[pallet::error]\n    pub enum Error&lt;T&gt; {\n        NotEnoughCurrency,\n        AccountAlreadyParticipating,\n        CanNotAddParticipant,\n    }\n\n    #[pallet::call]\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        #[pallet::call_index(0)]\n        #[pallet::weight(0)]\n        pub fn buy_ticket(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let buyer = ensure_signed(origin)?;\n\n            // 2. Checks that the user has enough balance to afford the ticket price\n            ensure!(\n                T::Currency::free_balance(&amp;buyer) &gt;= T::TicketCost::get(),\n                Error::&lt;T&gt;::NotEnoughCurrency\n            );\n\n            // 3. Checks that the user is not already participating\n            if let Some(participants) = Self::get_participants() {\n                ensure!(\n                    !participants.contains(&amp;buyer),\n                    Error::&lt;T&gt;::AccountAlreadyParticipating\n                );\n            }\n\n            // 4. Adds the user as a new participant for the prize\n            match Self::get_participants() {\n                Some(mut participants) =&gt; { \n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }, \n                None =&gt; {\n                    let mut participants = BoundedVec::new();\n                    ensure!(\n                        participants.try_push(buyer.clone()).is_ok(), \n                        Error::&lt;T&gt;::CanNotAddParticipant\n                    );\n                    Participants::&lt;T&gt;::set(Some(participants));\n                }\n            };\n\n            // 5. Transfers the ticket cost to the module's account\n            // to be hold until transferred to the winner\n            T::Currency::transfer(\n                &amp;buyer, \n                &amp;Self::get_pallet_account(), \n                T::TicketCost::get(), \n                ExistenceRequirement::KeepAlive)?;\n\n            // 6. Notify the event\n            Self::deposit_event(Event::TicketBought { who: buyer });\n            Ok(())\n        }\n\n        #[pallet::call_index(1)]\n        #[pallet::weight(0)]\n        pub fn award_prize(origin: OriginFor&lt;T&gt;) -&gt; DispatchResult {\n\n            // 1. Validates the origin signature\n            let _who = ensure_root(origin)?;\n\n            match Self::get_participants() {\n                Some(participants) =&gt; { \n\n                    // 2. Gets a random number from the randomness module\n                    let nonce = Self::get_and_increment_nonce();\n                    let (random_seed, _) = T::MyRandomness::random(&amp;nonce);\n                    let random_number = &lt;u32&gt;::decode(&amp;mut random_seed.as_ref())\n                        .expect(\"secure hashes should always be bigger than u32; qed\");\n\n                    // 3. Selects the winner from the participants lit\n                    let winner_index = random_number as usize % participants.len();\n                    let winner = participants.as_slice().get(winner_index).unwrap();\n\n                    // 4. Transfers the total prize to the winner's account\n                    let prize = T::Currency::free_balance(&amp;Self::get_pallet_account());\n                    T::Currency::transfer(\n                        &amp;Self::get_pallet_account(), \n                        &amp;winner, \n                        prize, \n                        ExistenceRequirement::AllowDeath)?;\n\n                    // 5. Resets the participants list, and gets ready for another lottery round\n                    Participants::&lt;T&gt;::kill();\n\n                    // 6. Notify the event\n                    Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );\n                }, \n                None =&gt; {\n                    // Notify the event (No participants)\n                    Self::deposit_event(Event::ThereAreNoParticipants);\n                }\n            };\n\n            Ok(())\n        }\n    }\n\n    impl&lt;T: Config&gt; Pallet&lt;T&gt; {\n\n        fn get_pallet_account() -&gt; T::AccountId {\n            T::PalletId::get().into_account_truncating()\n        }\n\n        fn get_and_increment_nonce() -&gt; Vec&lt;u8&gt; {\n            let nonce = Nonce::&lt;T&gt;::get();\n            Nonce::&lt;T&gt;::put(nonce.wrapping_add(1));\n            nonce.encode()\n        }\n    }\n}\n</code></pre> <p>For more information about the step-by-step process of creating a custom-made module to the runtime, please refer to the Adding a Custom-Made Module in the Builder's section.</p>"},{"location":"learn/framework/overview/","title":"Network Development Framework Overview","text":""},{"location":"learn/framework/overview/#introduction","title":"Introduction","text":"<p>Building a network from scratch is a very complex task that requires deep knowledge in a wide range of areas, including (but not limited to):</p> <ul> <li> <p>Consensus Algorithms - consensus ensures that all participants in the blockchain network agree on the validity of transactions. Some popular consensus mechanisms include Proof of Work (PoW) and Proof of Stake (PoS)</p> </li> <li> <p>Cryptography - cryptography plays a crucial role in securing the blockchain. You'll need cryptographic algorithms for tasks like creating digital signatures, verifying transactions, and encrypting data</p> </li> <li> <p>Distributed Network - a network architecture to enable nodes to communicate, validate transactions, and synchronize the blockchain data is key to maintaining a shared ledger in a decentralized network</p> </li> <li> <p>Data Structures - besides the list of blocks, where each block contains a set of transactions along with a reference to the previous block, an optimized and performant strategy to store the state of the network is needed</p> </li> <li> <p>Governance - if the network is designed to be permissionless, a voting mechanism is important in order to keep it evolving and reflecting the community will</p> </li> <li> <p>Upgradeability - it is necessary to clearly define how to upgrade, how modifications are implemented, and how conflicts are resolved within the network</p> </li> </ul> <p>Fortunately, there\u2019s no need to build these blockchain components from scratch, thanks to an excellent open-source framework called Substrate. Tanssi itself is built with this framework, leveraging its comprehensive base implementations, modularity, and flexibility to achieve a high level of customization.</p>"},{"location":"learn/framework/overview/#substrate-framework","title":"Substrate Framework","text":"<p>Substrate is an extremely performant, flexible, modular, and highly customizable framework for building blockchains. This framework is the foundation and engine powering many projects across the Web3 ecosystem, including the Tanssi network itself and the networks deployed through Tanssi.</p> <p>Many of its great features, such as performance, ease of use, and modularity, result from the programming language chosen for its development. This is where the Rust Programming Language shines: It is fast, portable, and provides a wonderful model to handle memory, among other reasons detailed in the next section.</p> <p>When developing a network, Substrate represents a great head start by providing a ready-to-use set of implementations of the main building blocks a project needs:</p> <ul> <li> <p>Consensus Algorithms - there are multiple built-in consensus engines, such as Aura (Proof of Authority), Babe (Proof of Stake), and Grandpa (block finality), but due to the high degree of customization Substrate offers, teams can always choose to develop their specific consensus to adapt to the use case needs, as the Moonbeam team did with the Nimbus Parachain Consensus Framework</p> </li> <li> <p>Runtime Modules - many built-in modules (explained in detail in the modules section) can be selected and configured into your network, such as accounts, balances, staking, governance, identity, and more</p> </li> <li> <p>Networking - built-in protocols and libraries for establishing connections, propagating transactions and blocks, synchronizing the blockchain state, and managing network interactions</p> </li> <li> <p>Storage - built-in storage mechanisms for efficient data storage and retrieval</p> </li> <li> <p>Transaction Queue - built-in transaction queue system that manages transaction validation, prioritization, and inclusion in blocks, ensuring the consistency and integrity of the network's state</p> </li> <li> <p>RPC APIs - Substrate provides Remote Procedure Call (RPC) APIs that enable external applications to interact with the network by querying blockchain data, submitting transactions, and accessing various functionalities exposed by the runtime</p> </li> </ul> <p>Every feature Substrate offers can be used as-is, extended, customized, or replaced to meet the specific requirements of the use case of the network.</p> <p>Substrate streamlines and speeds up the process of developing new networks. When used in conjunction with Tanssi, which helps in handling the infrastructure and overseeing the deployment, the task of launching a new network becomes significantly simpler!</p>"},{"location":"learn/framework/overview/#rust-programming-language","title":"Rust Programming Language","text":"<p>Rust is a programming language that has unique features that have made it the most loved language for the seventh consecutive year, according to Stack Overflow's annual developer survey.</p> <p>In addition to providing a great experience for developers, Rust excels in many areas:</p> <ul> <li> <p>Memory safety - Rust compiler enforces strict compile-time checks to prevent common programming errors such as null pointer dereferences, buffer overflows, and data races. Additionally, memory is managed through a novel system of ownership (checked by the compiler), which eliminates the necessity for a garbage collector</p> </li> <li> <p>Performance - Rust achieves performance comparable to that of C and C++ by providing low-level control over system resources and minimizing runtime overhead. It has a zero-cost abstraction principle, similar to \"what you don't use, you don't pay for\" from C++, meaning that abstractions have no extra overhead</p> </li> <li> <p>Concurrency - Rust has built-in features that make it easy to write concurrent and parallel code without introducing data races. It provides lightweight threads (tasks) and a powerful ownership model that ensures the safe sharing of data between threads</p> </li> <li> <p>Expressive and safe abstractions - Rust offers a rich set of modern language features, such as pattern matching, algebraic data types, closures, and type inference, allowing developers to write and read expressive and concise code. The Rust compiler enforces the strong type system, preventing many runtime errors at compile-time</p> </li> <li> <p>Cross-platform compatibility - Rust is designed to work well on a variety of platforms and architectures. It supports major operating systems like Windows, macOS, and Linux, as well as embedded systems and WebAssembly. This versatility allows developers to write code that can be deployed across different environments</p> </li> <li> <p>Growing ecosystem - Rust has a rapidly growing ecosystem with a vibrant community and a rich collection of libraries and tools. The official package manager, Cargo, simplifies dependency management, building, and testing</p> </li> <li> <p>Interoperability - Rust provides seamless interoperability with existing codebases written in C and C++. It has a Foreign Function Interface (FFI) that allows Rust code to interface with code written in other languages, enabling developers to gradually introduce Rust into existing projects, like the Linux kernel</p> </li> </ul>"},{"location":"fr/learn/framework/overview/#rust-programming-language","title":"Rust Programming Language","text":"<p>Rust is a programming language that has unique features that have made it the most loved language for the seventh consecutive year, according to Stack Overflow's annual developer survey.</p> <p>In addition to providing a great experience for developers, Rust excels in many areas:</p> <ul> <li> <p>Memory safety - Rust compiler enforces strict compile-time checks to prevent common programming errors such as null pointer dereferences, buffer overflows, and data races. Additionally, memory is managed through a novel system of ownership (checked by the compiler), which eliminates the necessity for a garbage collector</p> </li> <li> <p>Performance - Rust achieves performance comparable to that of C and C++ by providing low-level control over system resources and minimizing runtime overhead. It has a zero-cost abstraction principle, similar to \"what you don't use, you don't pay for\" from C++, meaning that abstractions have no extra overhead</p> </li> <li> <p>Concurrency - Rust has built-in features that make it easy to write concurrent and parallel code without introducing data races. It provides lightweight threads (tasks) and a powerful ownership model that ensures the safe sharing of data between threads</p> </li> <li> <p>Expressive and safe abstractions - Rust offers a rich set of modern language features, such as pattern matching, algebraic data types, closures, and type inference, allowing developers to write and read expressive and concise code. The Rust compiler enforces the strong type system, preventing many runtime errors at compile-time</p> </li> <li> <p>Cross-platform compatibility - Rust is designed to work well on a variety of platforms and architectures. It supports major operating systems like Windows, macOS, and Linux, as well as embedded systems and WebAssembly. This versatility allows developers to write code that can be deployed across different environments</p> </li> <li> <p>Growing ecosystem - Rust has a rapidly growing ecosystem with a vibrant community and a rich collection of libraries and tools. The official package manager, Cargo, simplifies dependency management, building, and testing</p> </li> <li> <p>Interoperability - Rust provides seamless interoperability with existing codebases written in C and C++. It has a Foreign Function Interface (FFI) that allows Rust code to interface with code written in other languages, enabling developers to gradually introduce Rust into existing projects, like the Linux kernel</p> </li> </ul>"}]}